{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Compose Unstyled","text":"<p>Unstyled, fully accessible components for Jetpack Compose &amp; Compose Multiplatform that you can customize to your heart's content.</p> <p>Available for \ud83d\udda5\ufe0f Desktop, \ud83c\udf10 Web (Js/WASM), \ud83e\udd16 Android, \ud83c\udf4e iOS, and any other platform Compose can run on.</p> Bottom Sheet Bottom Sheet (Modal) Dialog Dropdown Menu Icon Scroll Area Separators"},{"location":"#what-developers-say","title":"What developers say","text":"\"@alexstyl just wanted to let you know that we just transition from M3 Modal Bottom Sheet to your Compose Unstyled one and it fixed multiple issues \ud83c\udf89\"      Matt Kula <p>Android @ Warner Music Group</p>  \"Ever since Compose Unstyled was pointed out to me I use that one. Simpler API, and it actually works. I like it a lot, after continuously having something broken with the (Material Compose) bottom sheets.\"        Jacob Ras <p>Android Engineer @ Albert Heijn</p>  \"This man did, what Googlers couldn't in 3 years of scrollbars \"being on the roadmap\" #androiddev\"        Gabor Varadi <p>EpicPandaForce @ SO</p>        \"I wrote this library, so this will be biased \ud83d\ude01. I was tired of dealing with Material Compose sheets and dialogs issues, so I decided to write my own from scratch. Plus, I needed high-quality, non-Material looking components for my Compose Multiplatform (desktop) apps, hence this library was born.\"      Alex Styl <p>Author of Compose Unstyled</p>"},{"location":"#super-simple-migration","title":"Super simple migration","text":"<p>Check out Gravatar's PR of migrating their Modal Bottom Sheets from Material Compose to Compose Unstyled</p>"},{"location":"bottom-sheet/","title":"Bottom Sheet","text":"<p>A renderless, highly performant foundational component to build bottom sheets with, jam-packed with styling features without compromising on accessibility or keyboard interactions.</p>"},{"location":"bottom-sheet/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"bottom-sheet/#basic-example","title":"Basic Example","text":"<p>A bottom sheet consists of the following components: <code>BottomSheet</code> and the optional <code>DragIndication</code>.</p> <p>The <code>BottomSheet</code> component controls the area in which your sheet can be dragged and renders it within that area.</p> <p>The <code>DragIndication</code> is an optional component that can be used within the <code>BottomSheet</code>'s contents. It provides a way for the user to control the sheet without touch input.</p> <p>A bottom sheet has a set of specified <code>Detents</code>. Each detent specify the height in which the sheet can rest while not being dragged.</p> <p>By default, 2 detents are specified: <code>Hidden</code> and <code>FullyExpanded</code>.</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBox(Modifier.clickable { sheetState.currentDetent = FullyExpanded }) {\n    BasicText(\"Show Sheet\")\n}\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth(),\n) {\n    Box(\n        modifier = Modifier.fillMaxWidth().height(1200.dp),\n        contentAlignment = Alignment.TopCenter\n    ) {\n        DragIndication(Modifier.width(32.dp).height(4.dp))\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#styling","title":"Styling","text":"<p>The bottom sheet renders nothing on the screen by default. It manages a lot of states internally and leaves the styling to you.</p> <p>Any sort of styling is done by the <code>Modifier</code> of the respective component.</p> <p>Changing the looks of the bottom sheet is done by passing the respective styling <code>Modifier</code>s to your <code>BottomSheet</code> and <code>DragIndication</code>:</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier\n        .padding(top = 12.dp)\n        .shadow(4.dp, RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))\n        .clip(RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))\n        .background(Color.White)\n        .widthIn(max = 640.dp)\n        .fillMaxWidth()\n        .imePadding(),\n) {\n    Box(\n        modifier = Modifier.fillMaxWidth().height(1200.dp),\n        contentAlignment = Alignment.TopCenter\n    ) {\n        DragIndication(\n            modifier = Modifier\n                .padding(top = 22.dp)\n                .background(Color.Black.copy(0.4f), RoundedCornerShape(100))\n                .width(32.dp)\n                .height(4.dp)\n        )\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#code-examples","title":"Code Examples","text":""},{"location":"bottom-sheet/#showinghide-the-bottom-sheet","title":"Showing/Hide the bottom sheet","text":"<p>The visibility of the sheet is controlled by its state's currentDetent property.</p> <p>Pass <code>Hidden</code> to hide it, or <code>FullyExpanded</code> to fully expand it:</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBox(Modifier.clickable { sheetState.currentDetent = FullyExpanded }) {\n    BasicText(\"Show Sheet\")\n}\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth(),\n) {\n    Box(\n        modifier = Modifier.fillMaxWidth().height(1200.dp),\n        contentAlignment = Alignment.TopCenter\n    ) {\n        Box(Modifier.clickable { sheetState.currentDetent = Hidden }) {\n            BasicText(\"Hide Sheet\")\n        }\n    }\n}\n</code></pre> <p>Using the <code>currentDetent</code> property will cause the sheet to animate to given detent.</p>"},{"location":"bottom-sheet/#customizing-sheet-heights","title":"Customizing sheet heights","text":"<p>The heights in which the bottom sheet needs to stop for dragging purposes is controlled by the sheet's state <code>SheetDetent</code>s.</p> <p>To create a new detent, use the <code>SheetDetent</code> constructor to pass a unique identifier and a function which calculates the height of the detent at a given moment. The calculated value will be capped between <code>0.dp</code> and the content's height.</p> <p>NOTE: Make sure that the calculation returns fast, as this will affect your sheet's performance.</p> <p>Make sure to pass your new detent when creating your bottom sheet state:</p> <pre><code>val Peek = SheetDetent(identifier = \"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Hidden, Peek, FullyExpanded)\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth(),\n) {\n    Box(\n        modifier = Modifier\n            .fillMaxWidth()\n            .background(Color.White)\n            .height(1200.dp),\n        contentAlignment = Alignment.TopCenter\n    ) {\n        DragIndication(\n            modifier = Modifier\n                .padding(top = 22.dp)\n                .background(Color.Black.copy(0.4f), RoundedCornerShape(100))\n                .width(32.dp)\n                .height(4.dp)\n        )\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#drawing-behind-the-nav-bar","title":"Drawing behind the nav bar","text":"<p>The BottomSheet component works as a normal component and does not do anything special when it comes to System UI. This way you have full control over how you want your layout to be rendered.</p> <p>Nice looking bottom sheets tend to draw behind the platform's navigation bar while keeping their content above the navigation bar.</p> <p>The following code example showcases how to draw the bottom sheet behind the nav bar while ensuring its content is never blocked by the nav bar's buttons.</p> <p>At the same time, we make sure that the bottom sheet is never drawn behind the nav bars on landscape mode (for visual purposes):</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = FullyExpanded,\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .padding(\n            WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal)\n                .asPaddingValues()\n        )\n        .navigationBarsPadding(),\n) {\n    Column(\n        modifier = Modifier.fillMaxWidth(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n    ) {\n        DragIndication()\n        BasicText(\"Here is some content\")\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#working-with-the-soft-keyboard","title":"Working with the soft-keyboard","text":"<p>Add the <code>Modifier.imePadding()</code> in the contents of your sheet to make sure its contents are always drawn above the soft keyboard.</p> <p>Here is a styled example of a 'Add note' sheet:</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = FullyExpanded,\n)\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .padding(\n            // make sure the sheet is not behind nav bars on landscape\n            WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal)\n                .asPaddingValues()\n        )\n        .background(Color.White),\n) {\n    Column(\n        modifier = Modifier.fillMaxWidth()\n            .padding(16.dp)\n            // make sure the contents of the sheet is always above the nav bar\n            .navigationBarsPadding()\n            // draw the contents above the soft keyboard\n            .imePadding()\n    ) {\n        DragIndication(Modifier.align(Alignment.CenterHorizontally))\n\n        var text by remember { mutableStateOf(\"\") }\n        BasicTextField(\n            value = text,\n            onValueChange = { text = it },\n            modifier = Modifier.fillMaxWidth()\n        )\n        Box(Modifier\n            .clip(RoundedCornerShape(4.dp))\n            .background(Color.Blue)\n            .clickable { /* TODO */ }\n            .padding(4.dp)\n            .align(Alignment.End)) {\n            BasicText(\n                text = \"Save note\",\n                style = TextStyle.Default.copy(color = Color.White)\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#scrollable-sheets","title":"Scrollable sheets","text":"<p>Add any scrollable component within the contents of your sheet. <code>BottomSheet</code> supports nesting scrolling out of the box:</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = FullyExpanded,\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .background(Color.White),\n) {\n    Column(\n        modifier = Modifier.fillMaxWidth(),\n        horizontalAlignment = Alignment.CenterHorizontally,\n    ) {\n        DragIndication(Modifier.width(32.dp).height(4.dp))\n        LazyColumn {\n            repeat(50) {\n                item { BasicText(\"Item #${(it + 1)}\", modifier = Modifier.padding(10.dp)) }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#adding-transitions","title":"Adding transitions","text":"<p>Pass your own <code>AnimationSpec</code> when creating your sheet's state:</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n    animationSpec = spring(\n        dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow\n    )\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .background(Color.White)\n        .height(1200.dp),\n) {\n}\n</code></pre>"},{"location":"bottom-sheet/#listening-to-state-changes","title":"Listening to state changes","text":"<p>Use the sheet's state <code>currentDetent</code> to observe for state changes. This value returns the current detent the sheet is currently rested at.</p> <p>The <code>targetDetent</code> value returns the next detent the sheet is approaching (ie while being dragged).</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .background(Color.White)\n        .height(1200.dp),\n) {\n    Column {\n        BasicText(\"Current Detent = ${sheetState.currentDetent.identifier}\")\n        BasicText(\"Target Detent = ${sheetState.targetDetent.identifier}\")\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#listening-to-dragging-progress","title":"Listening to dragging progress","text":"<p>Use the state's <code>offset</code> value to listen to how far the sheet has moved within its container.</p> <p>If you are interested in listening to dragging events between detents, use the state's <code>progress</code> value instead:</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n)\n\nval alpha by animateFloatAsState(targetValue = sheetState.offset)\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth()\n        .alpha(alpha)\n        .background(Color.White)\n        .height(1200.dp),\n) {\n}\n</code></pre>"},{"location":"bottom-sheet/#jumping-to-detent-immediately","title":"Jumping to detent immediately","text":"<p>Use the <code>jumpTo()</code> function to move the sheet to the desired detent without any animation:</p> <pre><code>val sheetState = rememberBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBox(Modifier.clickable { sheetState.jumpTo(FullyExpanded) }) {\n    BasicText(\"Show Sheet\")\n}\n\nBottomSheet(\n    state = sheetState,\n    modifier = Modifier.fillMaxWidth(),\n) {\n    Box(\n        modifier = Modifier.fillMaxWidth().height(1200.dp),\n        contentAlignment = Alignment.TopCenter\n    ) {\n        Box(Modifier.clickable { sheetState.jumpTo(Hidden) }) {\n            BasicText(\"Hide Sheet\")\n        }\n    }\n}\n</code></pre>"},{"location":"bottom-sheet/#keyboard-interactions","title":"Keyboard Interactions","text":"<p>The <code>BottomSheet</code> component does not have any keyboard interactions, as it is 100% controlled by touch input.</p> <p>We strongly recommended to always include the <code>DragIndication</code> component within your sheet's content which enables the following keyboard interactions:</p> Key Action Tab Moves focus to or away from the drag indication Space / Enter Toggles between the available sheet's detents"},{"location":"bottom-sheet/#parameters","title":"Parameters","text":""},{"location":"bottom-sheet/#rememberbottomsheetstate","title":"rememberBottomSheetState()","text":"Parameter Description <code>initialDetent</code> A <code>SheetDetent</code> which controls the height in which the sheet will be introduced within its container. <code>sheetDetents</code> A list of <code>SheetDetent</code> which the sheet can be rested for dragging purposes. <code>animationSpec</code> An <code>AnimationSpec</code> used when animating the sheet across the different sheetDetents."},{"location":"bottom-sheet/#bottomsheetstate","title":"BottomSheetState","text":"Parameter Description <code>currentDetent</code> The <code>SheetDetent</code> in which the sheet is currently rested on. Setting a new detent will cause the sheet to animate to that detent. <code>targetDetent</code> The <code>SheetDetent</code> in which the sheet is about to rest on, if it is being dragged or animated. <code>isIdle</code> Whether the sheet is currently resting at a specific detent. <code>progress</code> A 0 to 1 <code>Float</code> which represents how far between two detents the sheet has currently moved. 1.0f for arrived at the end. <code>offset</code> A 0 to 1 <code>Float</code> which represents how far the sheet has moved within its dragging container. 1.0f for top of the container. <code>fun jumpTo()</code> Makes the sheet to immediately appear to the given detent without any animation. <code>suspend fun animateTo()</code> Animates the sheet to the given detent. This is a <code>suspend</code> function, which you can use to wait until the animation is complete."},{"location":"bottom-sheet/#bottomsheet","title":"BottomSheet()","text":"<p>The main component. Defines the area in which the sheet can be dragged in and renders the sheet.</p> Parameter Description <code>state</code> The <code>BottomSheetState</code> for the component <code>modifier</code> The <code>Modifier</code> for the component <code>enabled</code> Enables or disables dragging. <code>content</code> The contents of the sheet."},{"location":"bottom-sheet/#dragindication","title":"DragIndication()","text":"<p>A component that indicates that the sheet can be dragged.</p> Parameter Description <code>modifier</code> The <code>Modifier</code> for the component"},{"location":"bottom-sheet/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"},{"location":"dialog/","title":"Dialog","text":"<p>An unstyled Dialog component that can be used to implement Dialogs with the styling of your choice.</p> <p>Fully accessible, supports animations, offers consistent behavior across platforms and an optional background scrim.</p>"},{"location":"dialog/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"dialog/#basic-example","title":"Basic Example","text":"<p>A dialog consists of the following components: <code>Dialog</code>, <code>DialogPanel</code> and the optional <code>Scrim</code>.</p> <p>The <code>Dialog</code> controls the visibility of the dialog via the <code>DialogState</code> object.</p> <p>The <code>DialogPanel</code> is a container component that renders the dialog's panel and its contents.</p> <p>The optional <code>Scrim</code> component is used to add layer behind the dialog and dim the rest of the UI.</p> <pre><code>val dialogState = rememberDialogState()\n\nBox {\n    Box(Modifier.clickable { dialogState.visible = true }) {\n        BasicText(\"Show Dialog\")\n    }\n    Dialog(state = dialogState) {\n        DialogPanel(\n            modifier = Modifier\n                .displayCutoutPadding()\n                .systemBarsPadding()\n                .widthIn(min = 280.dp, max = 560.dp)\n                .padding(20.dp)\n                .clip(RoundedCornerShape(12.dp))\n                .border(1.dp, Color(0xFFE4E4E4), RoundedCornerShape(12.dp))\n                .background(Color.White),\n        ) {\n            Column {\n                Column(Modifier.padding(start = 24.dp, top = 24.dp, end = 24.dp)) {\n                    BasicText(\n                        text = \"Update Available\",\n                        style = TextStyle(fontWeight = FontWeight.Medium)\n                    )\n                    Spacer(Modifier.height(8.dp))\n                    BasicText(\n                        text = \"A new version of the app is available. Please update to the latest version.\",\n                        style = TextStyle(color = Color(0xFF474747))\n                    )\n                }\n                Spacer(Modifier.height(24.dp))\n                Box(Modifier.padding(12.dp)\n                    .align(Alignment.End)\n                    .clip(RoundedCornerShape(4.dp))\n                    .clickable(role = Role.Button) { /* TODO */ }\n                    .padding(horizontal = 12.dp, vertical = 8.dp)) {\n                    BasicText(\n                        text = \"Update\",\n                        style = TextStyle(color = Color(0xFF6699FF))\n                    )\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#styling","title":"Styling","text":"<p>Any sort of styling is done by the <code>Modifier</code> of the respective component.</p> <p>Changing the looks of the dialog's panel is done by passing the respective styling <code>Modifier</code>s to your <code>DialogPanel</code>:</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    DialogPanel(\n        modifier = Modifier.systemBarsPadding()\n            .widthIn(min = 280.dp, max = 560.dp)\n            .padding(20.dp)\n            .clip(RoundedCornerShape(12.dp))\n            .border(1.dp, Color(0xFFE4E4E4), RoundedCornerShape(12.dp))\n            .background(Color.White)\n    ) {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { /* TODO */ }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#code-examples","title":"Code Examples","text":""},{"location":"dialog/#showinghide-the-dialog","title":"Showing/Hide the dialog","text":"<p>Pass your own <code>DialogState</code> to the <code>Dialog</code> and change the visible property according to your needs:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    DialogPanel {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre> <p>The Dialog will also be automatically dismissed by default if the user taps outside the DialogPanel or presses the ' Escape' or 'Back' button on their device.</p> <p>In override to override this behavior pass the <code>DialogProperties</code> object to the Dialog with the desired properties:</p> <pre><code>Dialog(\n    state = rememberDialogState(),\n    properties = DialogProperties(dismissOnClickOutside = false, dismissOnBackPress = false)\n) {\n    // TODO the rest of your dialog\n}\n</code></pre>"},{"location":"dialog/#adding-a-scrim","title":"Adding a scrim","text":"<p>Use the <code>Scrim</code> component within your <code>Dialog</code>:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    Scrim()\n    DialogPanel {\n        Column {\n            BasicText(\"Something important happened\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre> <p>The <code>Scrim</code> is customizable and you can pass any scrimColor, and enter/exit transitions that matches your design specs.</p>"},{"location":"dialog/#scrollable-dialogs","title":"Scrollable dialogs","text":"<p>Add any scrollable component such as <code>LazyColumn</code> to the contents of your dialog:</p> <pre><code>val state = rememberDialogState()\n\nBox(Modifier.clickable { state.visible = true }) {\n    BasicText(\"Show dialog\")\n}\nDialog(state = state) {\n    DialogPanel {\n        Column {\n            LazyColumn(Modifier.height(320.dp)) {\n                item { BasicText(\"Something important happened\") }\n                repeat(100) { i -&gt;\n                    item { BasicText(\"Update number ${i}\") }\n                }\n            }\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#full-screen-dialogs","title":"Full-screen dialogs","text":"<p>Pass a <code>Modifier.fillMaxSize()</code> to the <code>DialogPanel</code>'s modifier parameter. Make sure to pass the <code>Modifier.systemBarsPadding()</code> and <code>Modifier.displayCutoutPadding()</code> or any related inset Modifier so that the dialog is not drawn behind any system bars (such as status and navigation bar on Android):</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    DialogPanel(\n        modifier = Modifier\n            .displayCutoutPadding()\n            .systemBarsPadding()\n            .fillMaxSize()\n    ) {\n        Column {\n            BasicText(\"This is a full screen dialog\")\n            Box(Modifier.clickable { state.visible = false }) {\n                BasicText(\"Got it\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"dialog/#adding-transitions","title":"Adding transitions","text":"<p>Add any enter/exit transitions into the <code>DialogPanel</code> and <code>Scrim</code> to control how they appear on the screen when they enter and exit the composition:</p> <pre><code>Dialog(state = rememberDialogState(visible = true)) {\n    Scrim(enter = fadeIn(), exit = fadeOut())\n    DialogPanel(\n        enter = scaleIn(initialScale = 0.8f) + fadeIn(tween(durationMillis = 250)),\n        exit = scaleOut(targetScale = 0.6f) + fadeOut(tween(durationMillis = 150)),\n    ) {\n        // TODO the dialog's contents\n    }\n}\n</code></pre>"},{"location":"dialog/#styling-the-system-bars","title":"Styling the system bars","text":"<p>Android only</p> <p>Dialogs will not change the color of your system UI when displayed. We provide a <code>LocalModalWindow</code> composition local, which provides you with the Android <code>Window</code> that hosts the dialog, so that you can customize the System UI according to your needs:</p> <pre><code>Dialog(rememberDialogState()) {\n    DialogPanel {\n        val window = LocalModalWindow.current\n        LaunchedEffect(Unit) {\n            // change system bars to transparent\n            window.statusBarColor = Color.Transparent.toArgb()\n            window.navigationBarColor = Color.Transparent.toArgb()\n\n            // don't forget to update the icons too\n            val windowInsetsController = WindowInsetsControllerCompat(window, window.decorView)\n            windowInsetsControllerCompat.isAppearanceLightStatusBars = true\n            windowInsetsControllerCompat.isAppearanceLightNavigationBars = true\n        }\n        BasicText(\"Transparent bars. So cool \ud83d\ude0e \", modifier = Modifier.navigationBarsPadding())\n    }\n}\n</code></pre>"},{"location":"dialog/#keyboard-interactions","title":"Keyboard Interactions","text":"Key Description Esc Closes any open dialogs, if the dismissOnBackPress of <code>DialogProperties()</code> is set to true. Back Closes any open dialogs, if the dismissOnBackPress of <code>DialogProperties()</code> is set to true. Tab Cycles through the dialog's contents. Shift + Tab Cycles through the dialog's contents in backwards order."},{"location":"dialog/#parameters","title":"Parameters","text":""},{"location":"dialog/#dialog_1","title":"Dialog","text":"<p>The main component.</p> Parameter Description <code>state</code> A <code>DialogState</code> object which controls the visibility of the dialog. <code>properties</code> Properties that control when the dialog needs to be dismissed (such as clicking outside of the panel or pressing Esc or Back. <code>onDismiss</code> Called when the dialog is being dismissed either by tapping outside or by pressing <code>Esc</code> or <code>Back</code>. <code>content</code> A <code>@Composable</code> function that provides a <code>DialogScope</code>."},{"location":"dialog/#dialogpanel","title":"DialogPanel","text":"<p>The visual representation of your dialog. Can only be used from a <code>DialogScope</code>.</p> Parameter Description <code>state</code> A <code>DialogState</code> object which controls the visibility of the dialog. <code>properties</code> Properties that control when the dialog needs to be dismissed (such as clicking outside of the panel or pressing Esc or Back. <code>content</code> A <code>@Composable</code> function that provides a <code>DialogScope</code>."},{"location":"dialog/#scrim","title":"Scrim","text":"<p>The dimming layer that is often placed behind a <code>DialogPanel</code>, to let the user focus on the dialog. Can only be used from a <code>DialogScope</code>.</p> Parameter Description <code>modifier</code> <code>Modifier</code> for the Scrim <code>scrimColor</code> Controls the color of the Scrim. The default color is Black with an alpha of 60%. <code>enter</code> The <code>EnterTransition</code> when the Scrim enters the composition <code>exit</code> The <code>ExitTransition</code> when the Scrim enters the composition"},{"location":"dialog/#compose-unstyled-dialog-vs-compose-dialog","title":"Compose Unstyled Dialog vs Compose Dialog","text":"<p>Compose Multiplatform's original Dialog component does not support custom animations. Even though it is possible to animate it, it requires you to combine multiple components together and sync state to animations to composition which is not straightforward to do.</p> <p>In addition, the Jetpack Compose (Android) Dialog comes with the original Android's dialog width and inset constraints, which are historically a pain to deal with and customize.</p> <p>Our Dialog is designed to be customizable inside out and work the same way on every platform without surprises. It behaves like any other component. If for example you need a full screen dialog, all you have to do is pass <code>Modifier.fillMaxSize()</code> to the <code>DialogPanel</code>, without having to worry about platform flags.</p>"},{"location":"dialog/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"},{"location":"dropdown-menu/","title":"Dropdown Menu","text":"<p>An unstyled component for Compose Multiplatform that can be used to implement Dropdown Menus with the styling of your choice. </p> <p>Fully accessible, supports keyboard navigation and open/close animations.</p>"},{"location":"dropdown-menu/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"dropdown-menu/#basic-example","title":"Basic Example","text":"<p>There are four components that you will use to implement a dropdown: <code>Menu</code>, <code>MenuButton</code>, <code>MenuContent</code> and <code>MenuItem</code>.</p> <p>The <code>Menu</code> wraps the <code>MenuButton</code> and the <code>MenuContent</code> components. When the <code>MenuButton</code> is clicked, the <code>MenuContent</code> will be displayed on the screen at the position relative to the <code>Menu</code>.</p> <p>The <code>MenuContent</code> component wraps multiple <code>MenuItem</code>s. When a <code>MenuItem</code> is clicked, the menu is dismissed. Each <code>MenuItem</code> has a <code>onClick</code> parameter you can use for interaction purposes.</p> <p>The menu's dropdown visibility is handled for you thanks to the <code>Menu</code>'s internal state.</p> <pre><code>val options = listOf(\"United States\", \"Greece\", \"Indonesia\", \"United Kingdom\")\nvar selected by remember { mutableStateOf(0) }\nval state = rememberMenuState(expanded = true)\n\nColumn(Modifier.fillMaxSize()) {\n    Menu(state, modifier = Modifier.align(Alignment.End)) {\n        MenuButton(\n            Modifier.clip(RoundedCornerShape(6.dp))\n                .border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))\n        ) {\n            Row(\n                modifier = Modifier.padding(horizontal = 14.dp, vertical = 10.dp),\n                verticalAlignment = Alignment.CenterVertically,\n            ) {\n                BasicText(\"Options\", style = defaultTextStyle.copy(fontWeight = FontWeight(500)))\n                Spacer(Modifier.width(4.dp))\n                Image(ChevronDown, null)\n            }\n        }\n\n        MenuContent(\n            modifier = Modifier.width(320.dp)\n                .border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp))\n                .background(Color.White)\n                .padding(4.dp),\n            exit = fadeOut()\n        ) {\n            options.forEachIndexed { index, option -&gt;\n                MenuItem(\n                    modifier = Modifier.clip(RoundedCornerShape(4.dp)),\n                    onClick = { selected = index }\n                ) {\n                    BasicText(option, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))\n                }\n            }\n        }\n    }\n    BasicText(\"Selected = ${options[selected]}\")\n}\n</code></pre>"},{"location":"dropdown-menu/#code-examples","title":"Code Examples","text":""},{"location":"dropdown-menu/#toggling-the-menu","title":"Toggling the Menu","text":"<p>Pass your own <code>MenuState</code> to the <code>Menu</code> and change the expanded property according to your needs:</p> <pre><code>val state = rememberMenuState(expanded = true)\n\nMenu(state = state) {\n    MenuButton {\n        BasicText(\"Toggle the menu\")\n    }\n\n    MenuContent {\n        MenuItem(onClick = { state.expanded = false }) {\n            BasicText(\"Close this menu\")\n        }\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#positioning-the-menu","title":"Positioning the menu","text":"<p>This option is useful if you want to left align, center align or right align the <code>MenuButton</code> and the <code>MenuContent</code> when expanded.</p> <pre><code>Menu {\n    MenuButton {\n        BasicText(\"Toggle the menu\")\n    }\n\n    MenuContent(alignment = Alignment.End) {\n        MenuItem(onClick = { /* TODO */ }) {\n            BasicText(\"Option\")\n        }\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#styling","title":"Styling","text":"<p>By default, the Menu component comes with no styling. This is by design as it is intended to be used as a building block for your own design system's menus.</p> <p>The <code>Menu</code> composable is used as an anchor point. Do not pass any styling to its <code>modifier</code>. Instead, use its <code>modifier</code> parameter for anchoring and positioning needs (such as <code>Modifier.align()</code>).</p> <p>The <code>MenuButton</code> is the composable responsible to handle clicking into showing and hiding the dropdown menu.</p> <p>The following sample shows the minimum setup you need to display something on the screen:</p> <pre><code>Menu {\n    MenuButton {\n        BasicText(\"Show Options\")\n    }\n\n    MenuContent {\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 1\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 2\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 3\")\n        }\n    }\n}\n</code></pre> <p>However, the result will not look pretty. The following section goes over how to style each component to achieve the visual results you want.</p>"},{"location":"dropdown-menu/#styling-the-menu-button","title":"Styling the Menu Button","text":"<p>Pass the desired styling to the <code>MenuButton</code>'s <code>modifier</code>. Do not pass any padding to it, as the <code>MenuButton</code> handles click events internally and this will affect the interaction bounds.</p> <p>Instead, provide any content padding to the contents of the button instead:</p> <pre><code>Menu {\n    MenuButton(Modifier.clip(RoundedCornerShape(6.dp)).border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))) {\n        BasicText(\"Options\", modifier = Modifier.padding(vertical = 8.dp, horizontal = 4.dp))\n    }\n\n    MenuContent {\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 1\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 2\")\n        }\n        MenuItem(onClick = { /* TODO handle click */ }) {\n            BasicText(\"Option 3\")\n        }\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#styling-the-menucontent","title":"Styling the MenuContent","text":"<p>The <code>MenuContent</code> component is a layout on which the menu's items will be displayed when the menu is expanded. In Material Design this is often a card.</p> <pre><code>Menu {\n    MenuButton(Modifier.clip(RoundedCornerShape(6.dp)).border(1.dp, Color(0xFFBDBDBD), RoundedCornerShape(6.dp))) {\n        BasicText(\"Options\", modifier = Modifier.padding(vertical = 8.dp, horizontal = 4.dp))\n    }\n\n    MenuContent(Modifier.width(320.dp).border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp)).background(Color.White).padding(4.dp)) {\n        MenuItem(onClick = { selected = index }) {\n            Text(option, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))\n        }\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#animating-the-menu","title":"Animating the Menu","text":"<p>Modify the <code>showTransition</code> and <code>hideTransition</code> parameters of the <code>MenuContent</code> component to modify the animation specs of the dropdown menu when it is visible/hidden.</p> <p>The <code>MenuContent</code> use the <code>AnimatedVisiblity</code> composable internally, which gives you a lot of flexibility towards what you can achieve.</p>"},{"location":"dropdown-menu/#animation-recipes","title":"Animation Recipes","text":""},{"location":"dropdown-menu/#material-design-dropdown","title":"Material Design Dropdown","text":"<p>Material Design scales and fades the dropdown in and out.</p> <pre><code>MenuContent(\n    modifier = Modifier.width(320.dp).border(1.dp, Color(0xFFE0E0E0), RoundedCornerShape(4.dp)).background(Color.White).padding(4.dp),\n    enter = scaleIn(tween(durationMillis = 120, easing = LinearOutSlowInEasing), initialScale = 0.8f, transformOrigin = TransformOrigin(0f, 0f)) + fadeIn(tween(durationMillis = 30)),\n    exit = scaleOut(tween(durationMillis = 1, delayMillis = 75), targetScale = 1f) + fadeOut(tween(durationMillis = 75))\n) {\n    MenuItem(onClick = { /* TODO */ }) {\n        BasicText(\"Option 1\")\n    }\n    MenuItem(onClick = { /* TODO */ }) {\n        BasicText(\"Option 2\")\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#mac-os-menu","title":"Mac OS Menu","text":"<p>macOS shows the menu instantly on click, and quickly fades the menu out when dismissed:</p> <pre><code>MenuContent(exit = fadeOut(tween(durationMillis = 100, easing = LinearEasing))) {\n    MenuItem(onClick = { /* TODO */ }) {\n        BasicText(\"Option 1\")\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#styling-touch-presses-and-focus","title":"Styling touch presses and focus","text":"<p><code>MenuItem</code>'s uses the default Compose mechanism for providing touch and focus feedback. Use the <code>LocalIndication</code> CompositionLocal to override the default indication.</p> <p>Here is an example of using Material Design's signature ripple feedback with your menu:</p> <pre><code>import androidx.compose.foundation.LocalIndication\nimport androidx.compose.material.ripple.rememberRipple\n\nCompositionLocalProvider(LocalIndication provides rememberRipple()) {\n    // MenuButton and MenuContent will use the ripple effect when focused and pressed\n\n    Menu {\n        // TODO implement the rest of the menu\n    }\n}\n</code></pre>"},{"location":"dropdown-menu/#keyboard-interactions","title":"Keyboard Interactions","text":"Key Description Enter Opens the Menu, if the <code>MenuButton</code> is focused. Performs a click, when a <code>MenuItem</code> is focused. \u2b07 Opens the Menu, if the <code>MenuButton</code> is focused. Moves focus to the next <code>MenuItem</code> if the <code>Menu</code> is expanded. \u2b06 Moves focus to the previous <code>MenuItem</code> if the <code>Menu</code> is expanded. Esc Closes the Menu, if the Menu is expanded and moves focus to the <code>MenuButton</code>. Removes focus if the <code>MenuButton</code> is focused."},{"location":"dropdown-menu/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at ComposablesUi.com</p> <p> </p>"},{"location":"icon/","title":"Icon","text":"<p>A component for rendering iconography with the tinting of your choice.</p>"},{"location":"icon/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"icon/#basic-example","title":"Basic Example","text":"<p>Basic example using Icons from the Material Extended Library:</p> <pre><code>Icon(\n    imageVector = Icons.Rounded.Favorite,\n    contentDescription = \"This song is in your favorites\",\n    tint = Color(0xFF9E9E9E),\n)\n</code></pre>"},{"location":"icon/#parameters","title":"Parameters","text":""},{"location":"icon/#icon_1","title":"Icon","text":"Parameter Description <code>painter</code> a <code>Painter</code>  to draw inside this icon. or <code>imageVector</code> a <code>ImageVector</code> to draw inside this icon. or <code>imageBitmap</code> an <code>ImageBitmap</code> to draw inside this icon. <code>contentDescription</code> text used by accessibility services to describe what this icon represents. This value can be ommited if the icon is used for stylistic purposes only. <code>modifier</code> the <code>Modifier</code> to be used to this icon. <code>tint</code> a <code>Color</code> that will be used to tint the <code>painter</code>. If <code>Color.Unspecified</code> is passed, then no tinting will be used."},{"location":"icon/#where-to-find-icons","title":"Where to find icons","text":"<p>Great apps require great iconography. Visit composeicons.com for a collection of over 7,000+ icons ready to be used in Jetpack Compose and Compose Multiplatform.</p>"},{"location":"icon/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"},{"location":"modal-bottom-sheet/","title":"Bottom Sheet (Modal)","text":"<p>A stackable, renderless, highly performant foundational component to build modal bottom sheets with, jam-packed with styling features without compromising on accessibility or keyboard interactions.</p>"},{"location":"modal-bottom-sheet/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#basic-example","title":"Basic Example","text":"<p>A modal bottom sheet consists of the following components: <code>ModalBottomSheet</code>, <code>Sheet</code> and the optional <code>Scrim</code> and <code>DragIndication</code>.</p> <p>The <code>ModalBottomSheet</code> controls the visibility of the modal bottom sheet. It renders its contents above any other layouts without having to worry about nesting.</p> <p>The <code>Sheet</code> is a container component that renders the bottom sheet and its contents.</p> <p>The <code>Scrim</code> component is used to add layer behind the dialog and dim the rest of the UI.</p> <p>The <code>DragIndication</code> can be used within the <code>Sheet</code>'s contents. It provides a way for the user to control the sheet without touch input.</p> <p>A bottom sheet has a set of specified <code>Detents</code>. Each detent specify the height in which the sheet can rest while not being dragged.</p> <p>By default, 2 detents are specified: <code>Hidden</code> and <code>FullyExpanded</code>.</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBox(Modifier.clickable { sheetState.currentDetent = FullyExpanded }) {\n    BasicText(\"Show Sheet\")\n}\n\nModalBottomSheet(state = sheetState) {\n    Sheet(modifier = Modifier.fillMaxWidth().background(Color.White)) {\n        Box(\n            modifier = Modifier.fillMaxWidth().height(1200.dp),\n            contentAlignment = Alignment.TopCenter\n        ) {\n            DragIndication()\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#styling","title":"Styling","text":"<p>The modal bottom sheet renders nothing on the screen by default. It manages a lot of states internally and leaves the styling to you.</p> <p>Any sort of styling is done by the <code>Modifier</code> of the respective component.</p> <p>Changing the looks of the bottom sheet is done by passing the respective styling <code>Modifier</code>s to your <code>Sheet</code>, <code>Scrim</code> and <code>DragIndication</code>:</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = FullyExpanded,\n)\n\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier\n            .padding(top = 12.dp)\n            .shadow(4.dp, RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))\n            .clip(RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))\n            .background(Color.White)\n            .widthIn(max = 640.dp)\n            .fillMaxWidth()\n            .imePadding(),\n    ) {\n        Box(\n            modifier = Modifier.fillMaxWidth().height(1200.dp),\n            contentAlignment = Alignment.TopCenter\n        ) {\n            DragIndication(\n                modifier = Modifier\n                    .padding(top = 22.dp)\n                    .background(Color.Black.copy(0.4f), RoundedCornerShape(100))\n                    .width(32.dp)\n                    .height(4.dp)\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#code-examples","title":"Code Examples","text":""},{"location":"modal-bottom-sheet/#showinghide-the-bottom-sheet","title":"Showing/Hide the bottom sheet","text":"<p>The visibility of the sheet is controlled by its state's currentDetent property.</p> <p>Pass <code>Hidden</code> to hide it, or <code>FullyExpanded</code> to fully expand it:</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = Hidden,\n)\n\nBox(Modifier.clickable { sheetState.currentDetent = FullyExpanded }) {\n    BasicText(\"Show Sheet\")\n}\n\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        state = sheetState,\n        modifier = Modifier.fillMaxWidth(),\n    ) {\n        Box(\n            modifier = Modifier.fillMaxWidth().height(1200.dp),\n            contentAlignment = Alignment.TopCenter\n        ) {\n            Box(Modifier.clickable { sheetState.currentDetent = Hidden }) {\n                BasicText(\"Hide Sheet\")\n            }\n        }\n    }\n}\n</code></pre> <p>Using the <code>currentDetent</code> property will cause the sheet to animate to given detent.</p>"},{"location":"modal-bottom-sheet/#customizing-sheet-heights","title":"Customizing sheet heights","text":"<p>The heights in which the bottom sheet needs to stop for dragging purposes is controlled by the sheet's state <code>SheetDetent</code>s.</p> <p>To create a new detent, use the <code>SheetDetent</code> constructor to pass a unique identifier and a function which calculates the height of the detent at a given moment. The calculated value will be capped between <code>0.dp</code> and the content's height.</p> <p>NOTE: Make sure that the calculation returns fast, as this will affect your sheet's performance.</p> <p>Make sure to pass your new detent when creating your bottom sheet state:</p> <pre><code>val Peek = SheetDetent(identifier = \"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberModalBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Hidden, Peek, FullyExpanded)\n)\n\nModalBottomSheet(state = sheetState) {\n    Sheet(modifier = Modifier.fillMaxWidth()) {\n        Box(\n            modifier = Modifier\n                .fillMaxWidth()\n                .background(Color.White)\n                .height(1200.dp),\n            contentAlignment = Alignment.TopCenter\n        ) {\n            DragIndication(\n                modifier = Modifier\n                    .padding(top = 22.dp)\n                    .background(Color.Black.copy(0.4f), RoundedCornerShape(100))\n                    .width(32.dp)\n                    .height(4.dp)\n            )\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#adding-a-scrim","title":"Adding a scrim","text":"<p>Use the <code>Scrim</code> component within your <code>ModalBottomSheet</code>:</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Hidden, Peek, FullyExpanded)\n)\n\nModalBottomSheet(state = sheetState) {\n    Scrim()\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .background(Color.White)\n            .height(1200.dp)\n    ) {\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#drawing-behind-the-nav-bar","title":"Drawing behind the nav bar","text":"<p>The ModalBottomSheet component is a modal component. When displayed on the screen, it dims the navigation bars and protect its icons.</p> <p>Other than that, you have full control over how you want sheet and its contents to be rendered on the screen.</p> <p>Nice looking bottom sheets tend to draw behind the platform's navigation bar while keeping their content above the navigation bar.</p> <p>The following code example showcases how to draw the bottom sheet behind the nav bar while ensuring its content is never blocked by the nav bar's buttons.</p> <p>At the same time, we make sure that the bottom sheet is never drawn behind the nav bars on landscape mode (for visual purposes):</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = FullyExpanded,\n)\n\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .padding(\n                WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal)\n                    .asPaddingValues()\n            )\n            .navigationBarsPadding(),\n    ) {\n        Column(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally,\n        ) {\n            DragIndication()\n            BasicText(\"Here is some content\")\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#working-with-the-soft-keyboard","title":"Working with the soft-keyboard","text":"<p>Add the <code>Modifier.imePadding()</code> in the contents of your sheet, to make sure that its contents are always draw above the soft keyboard.</p> <p>Here is a styled example of a 'Add note' sheet:</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = FullyExpanded,\n)\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .padding(\n                // make sure the sheet is not behind nav bars on landscape\n                WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal)\n                    .asPaddingValues()\n            )\n            .background(Color.White),\n    ) {\n        Column(\n            modifier = Modifier.fillMaxWidth()\n                .padding(16.dp)\n                // make sure the contents of the sheet is always above the nav bar\n                .navigationBarsPadding()\n                // draw the contents above the soft keyboard\n                .imePadding()\n        ) {\n            DragIndication(Modifier.align(Alignment.CenterHorizontally))\n\n            var text by remember { mutableStateOf(\"\") }\n            BasicTextField(\n                value = text,\n                onValueChange = { text = it },\n                modifier = Modifier.fillMaxWidth()\n            )\n            Box(Modifier\n                .clip(RoundedCornerShape(4.dp))\n                .background(Color.Blue)\n                .clickable { /* TODO */ }\n                .padding(4.dp)\n                .align(Alignment.End)) {\n                BasicText(\n                    text = \"Save note\",\n                    style = TextStyle.Default.copy(color = Color.White)\n                )\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#scrollable-sheets","title":"Scrollable sheets","text":"<p>Add any scrollable component within the contents of your sheet. <code>BottomSheet</code> supports nesting scrolling out of the box:</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = FullyExpanded,\n)\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .background(Color.White),\n    ) {\n        Column(\n            modifier = Modifier.fillMaxWidth(),\n            horizontalAlignment = Alignment.CenterHorizontally,\n        ) {\n            DragIndication(Modifier.width(32.dp).height(4.dp))\n            LazyColumn {\n                repeat(50) {\n                    item { BasicText(\"Item #${(it + 1)}\", modifier = Modifier.padding(10.dp)) }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#adding-transitions","title":"Adding transitions","text":"<p>Pass your own <code>AnimationSpec</code> when creating your sheet's state:</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberModalBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n    animationSpec = spring(\n        dampingRatio = Spring.DampingRatioMediumBouncy, stiffness = Spring.StiffnessLow\n    )\n)\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .background(Color.White)\n            .height(1200.dp),\n    ) {\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#listening-to-state-changes","title":"Listening to state changes","text":"<p>Use the sheet's state <code>currentDetent</code> to observe for state changes. This value returns the current detent the sheet is currently rested at.</p> <p>The <code>targetDetent</code> value returns the next detent the sheet is approaching (ie while being dragged).</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberModalBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n)\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .background(Color.White)\n            .height(1200.dp),\n    ) {\n        Column {\n            BasicText(\"Current Detent = ${sheetState.currentDetent.identifier}\")\n            BasicText(\"Target Detent = ${sheetState.targetDetent.identifier}\")\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#listening-to-dragging-progress","title":"Listening to dragging progress","text":"<p>Use the state's <code>offset</code> value to listen to how far the sheet has moved within its container.</p> <p>If you are interested in listening to dragging events between detents, use the state's <code>progress</code> value instead:</p> <pre><code>val Peek = SheetDetent(\"peek\") { containerHeight, sheetHeight -&gt;\n    containerHeight * 0.6f\n}\n\nval sheetState = rememberModalBottomSheetState(\n    initialDetent = Peek,\n    detents = listOf(Peek, FullyExpanded),\n)\n\nval alpha by animateFloatAsState(targetValue = sheetState.offset)\n\nModalBottomSheet(state = sheetState) {\n    Sheet(\n        modifier = Modifier.fillMaxWidth()\n            .alpha(alpha)\n            .background(Color.White)\n            .height(1200.dp),\n    ) {\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#jumping-to-detent-immediately","title":"Jumping to detent immediately","text":"<p>Use the <code>jumpTo()</code> function to move the sheet to the desired detent without any animation.</p> <p>NOTE: It is not currently possible to make the sheet enter the screen without an animation.</p> <pre><code>val sheetState = rememberModalBottomSheetState(\n    initialDetent = FullyExpanded,\n)\n\nModalBottomSheet(state = sheetState) {\n    Sheet(modifier = Modifier.fillMaxWidth()) {\n        Box(\n            modifier = Modifier.fillMaxWidth().height(1200.dp),\n            contentAlignment = Alignment.TopCenter\n        ) {\n            Box(Modifier.clickable { sheetState.jumpTo(Hidden) }) {\n                BasicText(\"Hide Sheet\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#styling-the-system-bars","title":"Styling the system bars","text":"<p>Android only</p> <p>ModalBottomSheet will not change the color of your system UI when displayed. We provide a <code>LocalModalWindow</code> composition local, which provides you with the Android <code>Window</code> that hosts the dialog, so that you can customize the System UI according to your needs:</p> <pre><code>ModalBottomSheet(rememberModalBottomSheetState(initialDetent = SheetDetent.FullyExpanded)) {\n    Sheet(Modifier.fillMaxWidth()) {\n        val window = LocalModalWindow.current\n        LaunchedEffect(Unit) {\n            // change system bars to transparent\n            window.statusBarColor = Color.Transparent.toArgb()\n            window.navigationBarColor = Color.Black.copy(0.33f).toArgb()\n\n            // don't forget to update the icons too\n            val windowInsetsController = WindowInsetsControllerCompat(window, window.decorView)\n            windowInsetsController.isAppearanceLightStatusBars = true\n            windowInsetsController.isAppearanceLightNavigationBars = false\n        }\n        BasicText(\n            \"Transparent status bar, darkened navbars. Easy-peasy \ud83d\ude0e \",\n            modifier = Modifier.navigationBarsPadding()\n        )\n    }\n}\n</code></pre>"},{"location":"modal-bottom-sheet/#keyboard-interactions","title":"Keyboard Interactions","text":"<p>The <code>BottomSheet</code> component does not have any keyboard interactions, as it is 100% controlled by touch input.</p> <p>We strongly recommended to always include the <code>DragIndication</code> component within your sheet's content which enables the following keyboard interactions:</p> Key Action Tab Moves focus to or away from the drag indication Space / Enter Toggles between the available sheet's detents"},{"location":"modal-bottom-sheet/#parameters","title":"Parameters","text":""},{"location":"modal-bottom-sheet/#remembermodalbottomsheetstate","title":"rememberModalBottomSheetState()","text":"Parameter Description <code>initialDetent</code> A <code>SheetDetent</code> which controls the height in which the sheet will be introduced within its container. <code>detents</code> A list of <code>SheetDetent</code> which the sheet can be rested for dragging purposes. <code>animationSpec</code> An <code>AnimationSpec</code> used when animating the sheet across the different sheetDetents. <code>positionalThreshold</code> The positional threshold, in px, to be used when calculating the target state while a drag is in progress and when settling after the drag ends. This is the distance from the start of a transition. It will be, depending on the direction of the interaction, added or subtracted from/to the origin offset. It should always be a positive value. <code>velocityThreshold</code> The velocity threshold (in px per second) that the end velocity has to exceed in order to animate to the next state, even if the [positionalThreshold] has not been reached."},{"location":"modal-bottom-sheet/#modalbottomsheetstate","title":"ModalBottomSheetState","text":"Parameter Description <code>currentDetent</code> The <code>SheetDetent</code> in which the sheet is currently rested on. Setting a new detent will cause the sheet to animate to that detent. <code>targetDetent</code> The <code>SheetDetent</code> in which the sheet is about to rest on, if it is being dragged or animated. <code>isIdle</code> Whether the sheet is currently resting at a specific detent. <code>progress</code> A 0 to 1 <code>Float</code> which represents how far between two detents the sheet has currently moved. 1.0f for arrived at the end. <code>offset</code> A 0 to 1 <code>Float</code> which represents how far the sheet has moved within its dragging container. 1.0f for top of the container. <code>fun jumpTo()</code> Makes the sheet to immediately appear to the given detent without any animation. <code>suspend fun animateTo()</code> Animates the sheet to the given detent. This is a <code>suspend</code> function, which you can use to wait until the animation is complete."},{"location":"modal-bottom-sheet/#modalbottomsheet","title":"ModalBottomSheet()","text":"<p>The main component. Defines the area in which the sheet can be dragged in.</p> Parameter Description <code>state</code> The <code>ModalBottomSheetState</code> for the component <code>properties</code> <code>ModalSheetProperties</code> that control whether the sheet needs to be dismissed on clicked outside, etc. <code>onDismiss</code> Called when the sheet is being dismissed either by tapping outside or by pressing <code>Esc</code> or <code>Back</code>. <code>content</code> The contents of the Modal Bottom Sheet."},{"location":"modal-bottom-sheet/#sheet","title":"Sheet()","text":"<p>Renders the sheet and its contents.</p> Parameter Description <code>modifier</code> The <code>Modifier</code> for the component <code>enabled</code> Enables or disables dragging. <code>content</code> The contents of the sheet."},{"location":"modal-bottom-sheet/#dragindication","title":"DragIndication()","text":"<p>A component that indicates that the sheet can be dragged.</p> Parameter Description <code>modifier</code> The <code>Modifier</code> for the component"},{"location":"modal-bottom-sheet/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"},{"location":"scrollarea/","title":"Scroll Area (Scrollbars)","text":"<p>Scroll Area can be used to add Scrollbars to any scrollable components.</p> <p>Comes with foundational, renderless vertical and horizontal <code>Scrollbar</code> components with tons of customization options.</p> <p>Supports scrollbars for <code>Column</code>, <code>Row</code>, <code>LazyColumn</code>, <code>LazyRow</code>, <code>LazyVerticalGrid</code> and <code>LazyHorizontalGrid</code>, fully customizable styling and custom overflow effects.</p>"},{"location":"scrollarea/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"scrollarea/#basic-example","title":"Basic Example","text":"<p>A scroll area consists of the following components: <code>ScrollArea</code>, <code>VerticalScrollbar</code>, <code>HorizontalScrollbar</code> and <code>Thumb</code>.</p> <p>The <code>ScrollArea</code> wraps a scrollable component (i.e. a <code>Column</code>, a <code>LazyRow</code> or <code>LazyGrid</code>) and maintains information about their scrolled position.</p> <p>The <code>VerticalScrollbar</code>/<code>HorizontalScrollbar</code> components represent the track of the scrollbar and accept a thumb component.</p> <p>The <code>Thumb</code> represents the thumb of a scrollbar and will automatically sync their position and size according to the scrolled position of the <code>ScrollArea</code>.</p> <p>Here is a simple example of adding vertical scrollbar to a <code>LazyColumn</code>:</p> <pre><code>val lazyListState = rememberLazyListState()\nval state = rememberScrollAreaState(lazyListState)\n\nScrollArea(state = state) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(\n        modifier = Modifier.align(Alignment.TopEnd)\n            .fillMaxHeight()\n            .width(4.dp)\n    ) {\n        Thumb(Modifier.background(Color.LightGray))\n    }\n}\n</code></pre>"},{"location":"scrollarea/#code-examples","title":"Code Examples","text":""},{"location":"scrollarea/#add-scrollbars-to-lazylists","title":"Add scrollbars to LazyLists","text":"<p>Wrap your <code>LazyColumn</code> or <code>LazyList</code> with a <code>ScrollArea</code> and pass its state to the scroll area's state:</p> <pre><code>val lazyListState = rememberLazyListState()\nval state = rememberScrollAreaState(lazyListState)\n\nScrollArea(state = state) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(\n        modifier = Modifier.align(Alignment.TopEnd)\n            .fillMaxHeight()\n            .width(4.dp)\n    ) {\n        Thumb(Modifier.background(Color.LightGray))\n    }\n}\n</code></pre>"},{"location":"scrollarea/#add-scrollbars-to-lazygrids","title":"Add scrollbars to LazyGrids","text":"<p>Wrap your <code>LazyVerticalGrid</code> or <code>LazyHorizontalGrid</code> with a <code>ScrollArea</code> and pass its state to the scroll area's state:</p> <pre><code>val lazyGridState = rememberLazyGridState()\nval state = rememberScrollAreaState(lazyGridState)\n\nScrollArea(state = state) {\n    LazyVerticalGrid(\n        columns = GridCells.Fixed(3),\n        state = lazyGridState,\n        modifier = Modifier.fillMaxSize()\n    ) {\n        repeat(50) { i -&gt;\n            item {\n                Box(\n                    Modifier.padding(4.dp).size(48.dp).background(Color.LightGray, RoundedCornerShape(8.dp)),\n                    contentAlignment = Alignment.Center\n                ) {\n                    BasicText(i.toString())\n                }\n            }\n        }\n    }\n    VerticalScrollbar(modifier = Modifier.align(Alignment.TopEnd).fillMaxHeight()) {\n        Thumb(\n            modifier = Modifier.background(Color.Black.copy(0.3f), RoundedCornerShape(100)),\n        )\n    }\n}\n</code></pre>"},{"location":"scrollarea/#add-scrollbars-to-column-and-row","title":"Add scrollbars to Column and Row","text":"<p>Wrap your <code>Column</code> or <code>Row</code> with a <code>ScrollArea</code> and pass the scroll state you used in your <code>vertical</code> state to the scroll area's state:</p> <pre><code>val scrollState = rememberScrollState()\nval state = rememberScrollAreaState(scrollState)\n\nScrollArea(state = state) {\n    Column(\n        modifier = Modifier.fillMaxSize().verticalScroll(scrollState)\n    ) {\n        repeat(50) { i -&gt;\n            BasicText(i.toString())\n        }\n    }\n    VerticalScrollbar(\n        modifier = Modifier.align(Alignment.TopEnd).fillMaxHeight()\n    ) {\n        Thumb(\n            modifier = Modifier.background(\n                Color.Black.copy(0.3f), RoundedCornerShape(100)\n            ),\n        )\n    }\n}\n</code></pre>"},{"location":"scrollarea/#styling-the-scrollbar-and-thumb","title":"Styling the scrollbar and thumb","text":"<p>Pass any styling you need to the <code>Modifier</code> of your <code>Scrollbar</code> component.</p> <p>You can customize the looks of your thumb using the modifier of the <code>Thumb</code> component.</p> <p>Here is an example of a semi-transparent scrollbar, with a fully rounded, semi-transparent thumb:</p> <pre><code>val lazyListState = rememberLazyListState()\nval state = rememberScrollAreaState(lazyListState)\n\nScrollArea(state = state) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(\n        modifier = Modifier.align(Alignment.TopEnd)\n            .background(Color.Black.copy(0.1f))\n            .fillMaxHeight()\n            .width(12.dp)\n            .padding(2.dp)\n    ) {\n        Thumb(Modifier.background(Color.Black.copy(0.3f), RoundedCornerShape(100)))\n    }\n}\n</code></pre>"},{"location":"scrollarea/#automatically-hide-the-scrollbar","title":"Automatically hide the scrollbar","text":"<p>By default, the scrollbar will always remain visible on the screen.</p> <p>To modify this behavior, pass the customization you need using the <code>thumbVisibility</code> parameter of the <code>Thumb</code> component.</p> <p>Here is an example of automatically hiding the scrollbar while idling for 0.5 seconds:</p> <pre><code>val lazyListState = rememberLazyListState()\nval state = rememberScrollAreaState(lazyListState)\n\nScrollArea(state = state) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(modifier = Modifier.align(Alignment.TopEnd).fillMaxHeight()) {\n        Thumb(\n            modifier = Modifier.background(Color.Black.copy(0.3f), RoundedCornerShape(100)),\n            thumbVisibility = ThumbVisibility.HideWhileIdle(\n                enter = fadeIn(),\n                exit = fadeOut(),\n                hideDelay = 0.5.seconds\n            )\n        )\n    }\n}\n</code></pre>"},{"location":"scrollarea/#customize-the-overscroll-effect","title":"Customize the overscroll effect","text":"<p>By default, the scroll area will use the platform's default <code>OverscrollEffect</code>.</p> <p>To remove it or provide your own custom effect, pass a new one via the <code>overscrollEffect</code> parameter:</p> <pre><code>val lazyListState = rememberLazyListState()\n\nScrollArea(\n    overscrollEffect = null,\n    state = rememberScrollAreaState(lazyListState),\n) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(\n        modifier = Modifier.align(Alignment.TopEnd)\n            .fillMaxHeight()\n            .width(4.dp)\n    ) {\n        Thumb(Modifier.background(Color.LightGray))\n    }\n}\n</code></pre>"},{"location":"scrollarea/#disable-thumb-dragging","title":"Disable thumb dragging","text":"<p>By default, pressing on the thumb will causes the contents of the scroll area to scroll (fast scroll).</p> <p>To disable this behavior, pass <code>enabled = false</code> to the <code>Thumb</code> component:</p> <pre><code>val lazyListState = rememberLazyListState()\nval state = rememberScrollAreaState(lazyListState)\n\nScrollArea(state = state) {\n    LazyColumn(state = lazyListState, modifier = Modifier.fillMaxSize()) {\n        repeat(50) { i -&gt;\n            item {\n                BasicText(\"Item #${i}\")\n            }\n        }\n    }\n    VerticalScrollbar(modifier = Modifier.align(Alignment.TopEnd).fillMaxHeight()) {\n        Thumb(\n            modifier = Modifier.background(Color.Black.copy(0.3f), RoundedCornerShape(100)),\n            enabled = false\n        )\n    }\n}\n</code></pre>"},{"location":"scrollarea/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"},{"location":"separators/","title":"Separator","text":"<p>A simple foundational separator component that shows a line to separate other components.</p>"},{"location":"separators/#installation","title":"Installation","text":"build.gradle.kts<pre><code>repositories {\n    mavenCentral()\n}\n\ndependencies {\n    implementation(\"com.composables:core:1.20.0\")\n}\n</code></pre>"},{"location":"separators/#basic-example","title":"Basic Example","text":"<p>Basic example showing a horizontal separator:</p> <pre><code>HorizontalSeparator(color = Color(0xFF9E9E9E))\n\nVerticalSeparator(color = Color(0xFF9E9E9E))\n</code></pre>"},{"location":"separators/#parameters","title":"Parameters","text":""},{"location":"separators/#verticalseparator-horizontalseparator","title":"VerticalSeparator / HorizontalSeparator","text":"Parameter Description <code>color</code> the <code>Color</code> of the separator. <code>thickness</code> a <code>Dp</code> of how thick the separator should rendered. <code>modifier</code> the <code>Modifier</code> to be used to this separator."},{"location":"separators/#styled-examples","title":"Styled Examples","text":"<p> <p>Looking for styled components for Jetpack Compose or Compose Multiplatform?</p> <p>Explore a rich collection of production ready examples at  ComposablesUi.com</p> <p> </p>"}]}